
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. 内置函数 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权信息" href="../copyright.html" />
    <link rel="next" title="3. Built-in Constants" href="constants.html" />
    <link rel="prev" title="1. Introduction" href="intro.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/functions.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="全文档索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. Introduction"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.6.5 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">The Python Standard Library</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="立即搜索" type="text" name="q" />
          <input type="submit" value="查找" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-functions">
<span id="built-in-funcs"></span><h1>2. 内置函数<a class="headerlink" href="#built-in-functions" title="永久链接至标题">¶</a></h1>
<p>Python 解释器内置了很多函数和类型，您可以在任何时候使用它们。以下按字母表顺序列出它们。</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="19%" />
<col width="20%" />
<col width="18%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head">内置函数</th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></td>
<td><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></td>
<td><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></td>
<td><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></td>
<td><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></td>
<td><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></td>
<td><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></td>
<td><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></td>
<td><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></td>
<td><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></td>
<td><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></td>
<td><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></td>
<td><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></td>
<td><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></td>
<td><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></td>
<td><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></td>
<td><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></td>
<td><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></td>
<td><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></td>
<td><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></td>
<td><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></td>
<td><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></td>
<td><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></td>
<td><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></td>
<td><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></td>
<td><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></td>
<td><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></td>
<td><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></td>
<td><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></td>
<td><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></td>
<td><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></td>
<td><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></td>
<td><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></td>
<td><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></td>
<td><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></td>
<td><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></td>
<td><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></td>
<td><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></td>
<td><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></td>
<td><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></td>
<td><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></td>
<td><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></td>
<td><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></td>
<td><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></td>
<td><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></td>
<td><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></td>
<td><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></td>
<td><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></td>
<td><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></td>
<td><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></td>
<td><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></td>
<td><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></td>
<td><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></td>
<td><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></td>
<td><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。</p>
</dd></dl>

<dl class="function">
<dt id="all">
<code class="descname">all</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#all" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>iterable</em> 的所有元素为 True（或 iterable 为空），返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="any">
<code class="descname">any</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#any" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>iterable</em> 的任一元素为 True，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。如果 iterable 为空，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ascii">
<code class="descname">ascii</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#ascii" title="永久链接至目标">¶</a></dt>
<dd><p>就像函数 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>，返回一个对象可打印的字符串，但是 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串中非 ASCII 编码的字符，会使用 <code class="docutils literal notranslate"><span class="pre">\x</span></code>、<code class="docutils literal notranslate"><span class="pre">\u</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\U</span></code> 来转义。生成的字符串和 Python 2 的 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的结果相似。</p>
</dd></dl>

<dl class="function">
<dt id="bin">
<code class="descname">bin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bin" title="永久链接至目标">¶</a></dt>
<dd><blockquote>
<div><p>将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，那它需要定义 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>  方法返回一个整数。一些例子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;0b11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;-0b1010&#39;</span>
</pre></div>
</div>
<p>如果不一定需要前缀“0b”，还可以使用如下的方法。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;#b&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:#b}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:b}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
</pre></div>
</div>
</div></blockquote>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
</dd></dl>

<dl class="class">
<dt id="bool">
<em class="property">class </em><code class="descname">bool</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个布尔值，<code class="docutils literal notranslate"><span class="pre">True</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>x</em> 使用标准的 <a class="reference internal" href="stdtypes.html#truth"><span class="std std-ref">真值测试过程</span></a> 来转换。如果 <em>x</em> 是假的或者被省略，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>；其他情况返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。<a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 类是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的子类（参见 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types — int, float, complex</span></a>）。其他类不能继承自它。它只有 <code class="docutils literal notranslate"><span class="pre">False</span></code> 和 <code class="docutils literal notranslate"><span class="pre">True</span></code> 两个实例（参见 <a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">Boolean Values</span></a>）。</p>
</dd></dl>

<span class="target" id="func-bytearray"><span id="index-0"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 bytes 数组。 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 <a class="reference internal" href="stdtypes.html#typesseq-mutable"><span class="std std-ref">Mutable Sequence Types</span></a> 的描述；同时有 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的大部分方法，参见 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">Bytes and Bytearray Operations</span></a>。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul class="simple">
<li>如果是一个 <em>string</em>，您必须提供 <em>encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 会使用 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 方法来将 string 转变成 bytes。</li>
<li>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</li>
<li>如果是一个符合 <em>buffer</em> 接口的对象，该对象的只读 buffer 会用来初始化字节数组。</li>
<li>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数，它会被用作数组的初始内容。</li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">Binary Sequence Types — bytes, bytearray, memoryview</span></a> 和 <a class="reference internal" href="stdtypes.html#typebytearray"><span class="std std-ref">Bytearray Objects</span></a>。</p>
</dd></dl>

<span class="target" id="func-bytes"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数。<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 是 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的不可变版本 - 它有其中不改变序列的方法和相同的索引、切片操作。</p>
<p>因此，构造函数的实参和 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 相同。</p>
<p>字节对象还可以用字面值创建，参见 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">String and Bytes literals</span></a>。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">Binary Sequence Types — bytes, bytearray, memoryview</span></a>，<a class="reference internal" href="stdtypes.html#typebytes"><span class="std std-ref">Bytes Objects</span></a> 和 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">Bytes and Bytearray Operations</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#callable" title="永久链接至目标">¶</a></dt>
<dd><p>如果实参 <em>object</em> 是可调用的，返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。如果返回真，调用仍可能会失败；但如果返回假，则调用 <em>object</em> 肯定会失败。注意类是可调用的（调用类会返回一个新的实例）。如果实例的类有 <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法，则它是可调用。</p>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能: </span>这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chr">
<code class="descname">chr</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#chr" title="永久链接至目标">¶</a></dt>
<dd><p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code class="docutils literal notranslate"><span class="pre">chr(97)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，<code class="docutils literal notranslate"><span class="pre">chr(8364)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'€'</span></code>。这是 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="classmethod">
<code class="descclassname">&#64;</code><code class="descname">classmethod</code><a class="headerlink" href="#classmethod" title="永久链接至目标">¶</a></dt>
<dd><p>把一个方法封装成类方法。</p>
<p>一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 形式是一个函数 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">装饰器</span></a> - 参见 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">Function definitions</span></a> 中关于函数定义的详细介绍。</p>
<p>它可以同时在类（如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>）和实例（如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>）上调用。实例除了它的类信息，其他都会被忽略。如果一个类方法在子类上调用，子类会作为第一个实参传入。</p>
<p>类方法和 C++ 和 Java 的静态方法是有区别的。如果你想要静态方法，请看本节的 <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。</p>
<p>关于类方法的更多信息，请参考文档 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">The standard type hierarchy</span></a> 中的标准类型的层次。</p>
</dd></dl>

<dl class="function">
<dt id="compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。参见 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块的文档了解如何使用 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code>；如果是单一表达式，可以是 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code>；如果是单个交互式语句，可以是 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>。（在最后一种情况下，如果表达式执行结果不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将会被打印出来。）</p>
<p>可选实参 <em>flags</em> 和 <em>dont_inherit</em> 控制编译 <em>source</em> 时会用到的 future 语句（参见 <span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a>）。如果两者都没提供（或都为零），则使用调用 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的代码中有效 future 语句来编译。如果给了 <em>flags</em> 实参但 <em>dont_inherit</em> 没有（或者为零），则 <em>flags</em> 指定的 future 语句以及那些无论如何会用到的 future 语句会被使用。如果 <em>dont_inherit</em> 是非零整数，则使用 <em>flags</em> 实参指定的，代码中有效的 future 语句会被忽略。</p>
<p>Future 语句使用比特位来指定，多个语句可以通过按位或来指定。具体特性的比特位可以通过 <a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>  模块中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">_Feature</span></code> 类的实例的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code> 属性来获得。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code class="docutils literal notranslate"><span class="pre">-1</span></code>  选择与解释器的 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项相同的优化级别。显式级别为 <code class="docutils literal notranslate"><span class="pre">0</span></code> （没有优化；<code class="docutils literal notranslate"><span class="pre">__debug__</span></code>  为真）、<code class="docutils literal notranslate"><span class="pre">1</span></code> （断言被删除， <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 为假）或 <code class="docutils literal notranslate"><span class="pre">2</span></code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常；如果源码包含 null 字节，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>如果您想分析 Python 代码的 AST 表示，请参阅 <a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>  或 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> 模块更容易检测语句的完整性。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">如果编译足够大或者足够复杂的字符串成 AST 对象时，Python 解释器会因为 Python AST 编译器的栈深度限制而奔溃。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.2 版更改: </span>允许使用 Windows 和 Mac 的换行符。在 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 模式不再需要以换行符结尾。增加了  <em>optimize</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>之前 <em>source</em> 中包含 null 字节的话会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="complex">
<em class="property">class </em><code class="descname">complex</code><span class="sig-paren">(</span><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#complex" title="永久链接至目标">¶</a></dt>
<dd><p>返回值为 <em>real</em> + <em>imag</em>*1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 <em>imag</em>，则默认值为零，构造函数会像 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 一样进行数值转换。如果两个实参都省略，则返回 <code class="docutils literal notranslate"><span class="pre">0j</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">当从字符串转换时，字符串在 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> 的周围必须不能有空格。例如 <code class="docutils literal notranslate"><span class="pre">complex('1+2j')</span></code> 是合法的，但 <code class="docutils literal notranslate"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> 会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types — int, float, complex</span></a> 描述了复数类型。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="delattr">
<code class="descname">delattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#delattr" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 <code class="docutils literal notranslate"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code>  等价于 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x.foobar</span></code> 。</p>
</dd></dl>

<span class="target" id="func-dict"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的字典。<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 对象是一个字典类。参见 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和 <a class="reference internal" href="stdtypes.html#typesmapping"><span class="std std-ref">Mapping Types — dict</span></a> 了解这个类。</p>
<p>其他容器类型，请参见内置的 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="function">
<dt id="dir">
<code class="descname">dir</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dir" title="永久链接至目标">¶</a></dt>
<dd><p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 函数的对象能够自定义 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 来报告它们的属性。</p>
<p>如果对象不提供 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a>，这个函数会尝试从对象已定义的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>，那结果可能不准确。</p>
<p>默认的 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul class="simple">
<li>如果对象是模块对象，则列表包含模块的属性名称。</li>
<li>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</li>
<li>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">因为 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#divmod" title="永久链接至目标">¶</a></dt>
<dd><p>它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 一致。对于浮点数，结果是 <code class="docutils literal notranslate"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> ，<em>q</em> 通常是 <code class="docutils literal notranslate"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code> 但可能会比 1 小。在任何情况下， <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 和  <em>a</em> 基本相等；如果 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 非零，它的符号和 <em>b</em> 一样，并且 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code> 。</p>
</dd></dl>

<dl class="function">
<dt id="enumerate">
<code class="descname">enumerate</code><span class="sig-paren">(</span><em>iterable</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#enumerate" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">迭代器</span></a>，或其他支持迭代的对象。 <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 返回的迭代器的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#eval" title="永久链接至目标">¶</a></dt>
<dd><p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p><em>expression</em> 实参被解析并执行成 Python 表达式（从技术上讲，是条件列表），<em>globals</em> 和 <em>locals</em> 字典分别用作全局和本地命名空间。如果 <em>globals</em> 字典存在但缺少“__builtins__”，那么当前的全局变量会在解析 <em>expression</em> 前被拷贝进 <em>globals</em>；这意味着，<em>expression</em> 通常可以完全访问标准的 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块，并且受限制的环境会传播。如果 <em>locals</em> 被省略了，那它的默认值是 <em>globals</em> 字典。如果两个字典变量都被省略了，则在 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>  被调用的环境中执行表达式。函数的返回值是表达式执行的结果。语法错误会产生异常。如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>这个函数也可以用来执行任何代码对象（如 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>  创建的）。这种情况下，参数是代码对象，而不是字符串。如果编译该对象时的 <em>mode</em> 实参是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 那么 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 返回值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>提示： <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数支持动态执行语句。 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此您可以将它们传递给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 或 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 来使用。</p>
<p>另外可以参阅 <a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code></a>，该函数可以安全执行仅包含文字的表达式字符串。</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="function">
<dt id="exec">
<code class="descname">exec</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#exec" title="永久链接至目标">¶</a></dt>
<dd><p>这个函数支持动态执行 Python 代码。<em>object</em> 必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。<a class="footnote-reference" href="#id2" id="id1">[1]</a> 如果是代码对象，它将被直接执行。在任何情况下，被执行的代码都需要和文件输入一样是有效的（见参考手册中关于文件输入的章节）。请注意即使在传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数的代码的上下文中，<a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 和 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句也不能在函数定义之外使用。该函数返回值是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>无论哪种情况，如果省略了可选参数，代码将在当前范围内执行。如果提供了 <em>globals</em> 参数，就必须是字典类型，而且会被用作全局和本地变量。如果同时提供了 <em>globals</em> 和 <em>locals</em> 参数，它们分别被用作全局和本地变量。如果提供了 <em>locals</em> 参数，则它可以是任何映射型的对象。请记住在模块层级，全局和本地变量是相同的字典。如果 exec 有两个不同的 <em>globals</em> 和 <em>locals</em> 对象，代码就像嵌入在类定义中一样执行。</p>
<p>如果 <em>globals</em> 字典不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键值，则将为该键插入对内建 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块字典的引用。因此，在将执行的代码传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 之前，可以通过将自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">内置 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 的第二个和第三个实参。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">默认情况下，<em>locals</em> 的行为如下面 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。如果您想在 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数返回时知道代码对 <em>locals</em> 的变动，请明确地传递 <em>locals</em> 字典。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#filter" title="永久链接至目标">¶</a></dt>
<dd><p>用 <em>iterable</em>  中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 相当于一个生成器表达式，当 function 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code>；function 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> 。</p>
<p>请参阅 <a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.filterfalse()</span></code></a> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
</dd></dl>

<dl class="class">
<dt id="float">
<em class="property">class </em><code class="descname">float</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#float" title="永久链接至目标">¶</a></dt>
<dd><p id="index-3">返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> ； <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 对创建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。确切地说，除去首尾的空格后，输入必须遵循以下语法：</p>
<pre>
<strong id="grammar-token-sign">sign          </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-infinity">infinity      </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-nan">nan           </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-numeric_value">numeric_value </strong> ::=  <a class="reference internal" href="../reference/lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-infinity"><code class="xref docutils literal notranslate"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-nan"><code class="xref docutils literal notranslate"><span class="pre">nan</span></code></a>
<strong id="grammar-token-numeric_string">numeric_string</strong> ::=  [<a class="reference internal" href="#grammar-token-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-numeric_value"><code class="xref docutils literal notranslate"><span class="pre">numeric_value</span></code></a>
</pre>
<p>这里， <code class="docutils literal notranslate"><span class="pre">floatnumber</span></code> 是 Python 浮点数的字符串形式，详见 <a class="reference internal" href="../reference/lexical_analysis.html#floating"><span class="std std-ref">Floating point literals</span></a>。字母大小写都可以，例如，“inf”、“Inf”、“INFINITY”、“iNfINity” 都可以表示正无穷大。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p>对于一般的 Python 对象 <code class="docutils literal notranslate"><span class="pre">x</span></code> ， <code class="docutils literal notranslate"><span class="pre">float(x)</span></code> 指派给 <code class="docutils literal notranslate"><span class="pre">x.__float__()</span></code> 。</p>
<p>如果没有实参，则返回 <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types — int, float, complex</span></a> 描述了浮点类型。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
</dd></dl>

<span class="target" id="index-4"></span><dl class="function">
<dt id="format">
<code class="descname">format</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#format" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>value</em> 转换为 <em>format_spec</em> 控制的“格式化”表示。<em>format_spec</em> 的解释取决于 <em>value</em> 实参的类型，但是大多数内置类型使用标准格式化语法：<a class="reference internal" href="string.html#formatspec"><span class="std std-ref">Format Specification Mini-Language</span></a>。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常和调用 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(value)</span></code></a> 的结果相同。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> 会转换成  <code class="docutils literal notranslate"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code> ，所以实例字典中的 <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法将不会调用。如果搜索到 <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal notranslate"><span class="pre">object</span></code></a> 有这个方法但  <em>format_spec</em> 不为空，<em>format_spec</em> 或返回值不是字符串，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>当 <em>format_spec</em> 不是空字符串时， <code class="docutils literal notranslate"><span class="pre">object().__format__(format_spec)</span></code> 会触发  <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<span class="target" id="func-frozenset"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code class="docutils literal notranslate"><span class="pre">frozenset</span></code> 是一个内置的类。有关此类的文档，请参阅 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 和 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">Set Types — set, frozenset</span></a>。</p>
<p>请参阅内建的 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>、<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块来了解其它的容器。</p>
</dd></dl>

<dl class="function">
<dt id="getattr">
<code class="descname">getattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#getattr" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象命名属性的值。<em>name</em> 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， <code class="docutils literal notranslate"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span></code>。如果指定的属性不存在，且提供了 <em>default</em> 值，则返回它，否则触发 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
</dd></dl>

<dl class="function">
<dt id="globals">
<code class="descname">globals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#globals" title="永久链接至目标">¶</a></dt>
<dd><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p>
</dd></dl>

<dl class="function">
<dt id="hasattr">
<code class="descname">hasattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hasattr" title="永久链接至目标">¶</a></dt>
<dd><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。（此功能是通过调用 <code class="docutils literal notranslate"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> 看是否有 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 异常来实现的。）</p>
</dd></dl>

<dl class="function">
<dt id="hash">
<code class="descname">hash</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#hash" title="永久链接至目标">¶</a></dt>
<dd><blockquote>
<div>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果对象实现了自己的 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法，请注意，<a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 根据机器的字长来截断返回值。另请参阅 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#help" title="永久链接至目标">¶</a></dt>
<dd><p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>该函数通过 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块加入到内置命名空间。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 和 <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 的变更使得可调用对象的签名信息更加全面和一致。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hex">
<code class="descname">hex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="永久链接至目标">¶</a></dt>
<dd><p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则必须定义返回整数的 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。一些例子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;#x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:#x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:X}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<p>另请参阅 <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 将十六进制字符串转换为以 16 为基数的整数。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果要获取浮点数的十六进制字符串形式，请使用 <a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 方法。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="id">
<code class="descname">id</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#id" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 值。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> This is the address of the object in memory.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="optional">[</span><em>prompt</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#input" title="永久链接至目标">¶</a></dt>
<dd><p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p>如果加载了 <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块，<a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 将使用它来提供复杂的行编辑和历史记录功能。</p>
</dd></dl>

<dl class="class">
<dt id="int">
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x=0</em><span class="sig-paren">)</span><a class="headerlink" href="#int" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x</em>, <em>base=10</em><span class="sig-paren">)</span></dt>
<dd><p>返回一个使用数字或字符串 <em>x</em> 生成的整数对象，或者没有实参的时候返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。如果 <em>x</em> 定义了 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>，<code class="docutils literal notranslate"><span class="pre">int(x)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">x.__int__()</span></code> 。如果 <em>x</em> 定义了 <a class="reference internal" href="../reference/datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a>，它返回 <code class="docutils literal notranslate"><span class="pre">x.__trunc__()</span></code> 。对于浮点数，它向零舍入。</p>
<p>如果 <em>x</em> 不是数字，或者有 <em>base</em> 参数，<em>x</em> 必须是字符串、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、表示进制为 <em>base</em> 的 <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">整数文字</span></a> 的 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 实例。该文字前可以有 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 <code class="docutils literal notranslate"><span class="pre">a</span></code> 到 <code class="docutils literal notranslate"><span class="pre">z</span></code> （或 <code class="docutils literal notranslate"><span class="pre">A</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Z</span></code> ）表示 10 到 35。默认的 <em>base</em> 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 <code class="docutils literal notranslate"><span class="pre">0b</span></code>/<code class="docutils literal notranslate"><span class="pre">0B</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0o</span></code>/<code class="docutils literal notranslate"><span class="pre">0O</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0x</span></code>/<code class="docutils literal notranslate"><span class="pre">0X</span></code> 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">0)</span></code> 是非法的，但 <code class="docutils literal notranslate"><span class="pre">int('010')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">8)</span></code> 是合法的。</p>
<p>整数类型定义请参阅 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types — int, float, complex</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>如果 <em>base</em> 不是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例，但 <em>base</em> 对象有 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 方法，则会调用该方法来获取进制数。以前的版本使用 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__int__</span></code></a> 而不是 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="isinstance">
<code class="descname">isinstance</code><span class="sig-paren">(</span><em>object</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#isinstance" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>object</em> 实参是 <em>classinfo</em> 实参的实例，或者是（直接、间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a>）子类的实例，则返回 true。如果 <em>object</em> 不是给定类型的对象，函数始终返回 false。如果 <em>classinfo</em> 是对象类型（或多个递归元组）的元组，如果 <em>object</em> 是其中的任何一个的实例则返回 true。 如果 <em>classinfo</em> 既不是类型，也不是类型元组或类型的递归元组，那么会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="issubclass">
<code class="descname">issubclass</code><span class="sig-paren">(</span><em>class</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#issubclass" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>class</em> 是 <em>classinfo</em> 的子类（直接、间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a> 的），则返回 true。<em>classinfo</em> 可以是类对象的元组，此时 <em>classinfo</em> 中的每个元素都会被检查。其他情况，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#iter" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">迭代器</span></a> 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持迭代协议（有 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法）的集合对象，或必须支持序列协议（有 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法，且数字参数从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始）。如果它不支持这些协议，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。如果有第二个实参 <em>sentinel</em>，那么 <em>object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法时都会不带实参地调用 <em>object</em>；如果返回的结果是 <em>sentinel</em> 则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，否则返回调用结果。</p>
<p>另请参阅 <a class="reference internal" href="stdtypes.html#typeiter"><span class="std std-ref">Iterator Types</span></a>。</p>
<p><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 的第二种形式的一个有用的用法是将文件读到特定行。在下面的例子中，我们将读取文件，直到 <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 方法返回一个空字符串</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="len">
<code class="descname">len</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
</dd></dl>

<span class="target" id="func-list"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>除了是函数，<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 也是可变序列类型，详情请参阅 <a class="reference internal" href="stdtypes.html#typesseq-list"><span class="std std-ref">列表</span></a> 和 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="locals">
<code class="descname">locals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#locals" title="永久链接至目标">¶</a></dt>
<dd><p>更新并返回表示当前本地符号表的字典。在函数块而不是类块中调用 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 时会返回自由变量。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="map">
<code class="descname">map</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#map" title="永久链接至目标">¶</a></dt>
<dd><p>产生一个将 <em>function</em> 应用于迭代器中所有元素并返回结果的迭代器。如果传递了额外的 <em>iterable</em> 实参，<em>function</em> 必须接受相同个数的实参，并使用所有迭代器中并行获取的元素。当有多个迭代器时，最短的迭代器耗尽则整个迭代结束。如果函数的输入已经是元组实参，请参阅 <a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.starmap()</span></code></a>。</p>
</dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#max" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">max</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个 positional 实参，它必须是非空 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">可迭代对象</span></a>，返回可迭代对象中最大的元素；如果提供了两个及以上的 positional 实参，则返回最大的 positional 实参。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
</dd></dl>

<span class="target" id="func-memoryview"></span><dl class="function">
<dt>
<code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></dt>
<dd><p>返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.html#typememoryview"><span class="std std-ref">Memory Views</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#min" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">min</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个 positional 实参，它必须是 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">可迭代对象</span></a>，返回可迭代对象中最小的元素；如果提供了两个及以上的 positional 实参，则返回最小的 positional 实参。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="next">
<code class="descname">next</code><span class="sig-paren">(</span><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#next" title="永久链接至目标">¶</a></dt>
<dd><p>通过调用 <em>iterator</em> 的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。</p>
</dd></dl>

<dl class="class">
<dt id="object">
<em class="property">class </em><code class="descname">object</code><a class="headerlink" href="#object" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个没有特征的新对象。<a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">由于 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 没有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>，因此无法将任意属性赋给 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的实例。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="oct">
<code class="descname">oct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#oct" title="永久链接至目标">¶</a></dt>
<dd><p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，那它需要定义 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>  方法返回一个整数。一些例子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0o10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="o">-</span><span class="mi">56</span><span class="p">)</span>
<span class="go">&#39;-0o70&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为八进制字符串，并可选择有无“0o”前缀，则可以使用如下方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;#o&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:#o}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:o}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<blockquote>
<div><span class="target" id="index-5"></span></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span><a class="headerlink" href="#open" title="永久链接至目标">¶</a></dt>
<dd><p>打开 <em>file</em> 并返回对应的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>。如果该文件不能打开，则触发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<p><em>file</em> 是将要打开的文件的路径（绝对路径或者当前工作目录的相当路径），是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like 对象</span></a>；也可能是要被封装的文件描述符的数字。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 <em>closefd</em> 是 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。）</p>
<p><em>mode</em> 是一个可选字符串，用于指定打开文件的模式。默认值是 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>  ，这意味着它以文本模式打开并读取。其他常见模式有：写入 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> （截断已经存在的文件）；排它性创建 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ；追加写 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> （在 <em>一些</em>  Unix 系统上，无论当前的文件指针在什么位置，<em>所有</em> 写入都会追加到文件末尾）。在文本模式，如果 <em>encoding</em> 没有指定，则根据平台来决定使用的编码：使用 <code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code> 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 <em>encoding</em>。）可用的模式有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">字符</th>
<th class="head">意义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'r'</span></code></td>
<td>读取（默认）</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'w'</span></code></td>
<td>写入，并先截断文件</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'x'</span></code></td>
<td>排它性创建，如果文件已存在则失败</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'a'</span></code></td>
<td>写入，如果文件存在则在末尾追加</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'b'</span></code></td>
<td>二进制模式</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'t'</span></code></td>
<td>文本模式（默认）</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'+'</span></code></td>
<td>更新磁盘文件（读取并写入）</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'U'</span></code></td>
<td><a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">通用换行</span></a> 模式（已弃用）</td>
</tr>
</tbody>
</table>
<p>默认的模式是 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> （打开并读取文本，同 <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> ）。对于二进制写入， <code class="docutils literal notranslate"><span class="pre">'w+b'</span></code> 模式打开并把文件截断成 0 字节； <code class="docutils literal notranslate"><span class="pre">'r+b'</span></code> 则不会截断。</p>
<p>As mentioned in the <a class="reference internal" href="io.html#io-overview"><span class="std std-ref">Overview</span></a>, Python distinguishes between binary
and text I/O.  Files opened in binary mode (including <code class="docutils literal notranslate"><span class="pre">'b'</span></code> in the <em>mode</em>
argument) return contents as <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects without any decoding.  In
text mode (the default, or when <code class="docutils literal notranslate"><span class="pre">'t'</span></code> is included in the <em>mode</em> argument),
the contents of the file are returned as <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, the bytes having been
first decoded using a platform-dependent encoding or using the specified
<em>encoding</em> if given.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Python doesn’t depend on the underlying operating system’s notion of text
files; all the processing is done by Python itself, and is therefore
platform-independent.</p>
</div>
<p><em>buffering</em> is an optional integer used to set the buffering policy.  Pass 0
to switch buffering off (only allowed in binary mode), 1 to select line
buffering (only usable in text mode), and an integer &gt; 1 to indicate the size
in bytes of a fixed-size chunk buffer.  When no <em>buffering</em> argument is
given, the default buffering policy works as follows:</p>
<ul class="simple">
<li>Binary files are buffered in fixed-size chunks; the size of the buffer is
chosen using a heuristic trying to determine the underlying device’s “block
size” and falling back on <a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a>.  On many systems,
the buffer will typically be 4096 or 8192 bytes long.</li>
<li>“Interactive” text files (files for which <a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code></a>
returns <code class="docutils literal notranslate"><span class="pre">True</span></code>) use line buffering.  Other text files use the policy
described above for binary files.</li>
</ul>
<p><em>encoding</em> is the name of the encoding used to decode or encode the file.
This should only be used in text mode.  The default encoding is platform
dependent (whatever <a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getpreferredencoding()</span></code></a> returns), but any
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> supported by Python
can be used.  See the <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> module for
the list of supported encodings.</p>
<p><em>errors</em> is an optional string that specifies how encoding and decoding
errors are to be handled—this cannot be used in binary mode.
A variety of standard error handlers are available
(listed under <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a>), though any
error handling name that has been registered with
<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> is also valid.  The standard names
include:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> to raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> exception if there is
an encoding error.  The default value of <code class="docutils literal notranslate"><span class="pre">None</span></code> has the same
effect.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> ignores errors.  Note that ignoring encoding errors
can lead to data loss.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> causes a replacement marker (such as <code class="docutils literal notranslate"><span class="pre">'?'</span></code>) to be inserted
where there is malformed data.</li>
<li><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> will represent any incorrect bytes as code
points in the Unicode Private Use Area ranging from U+DC80 to
U+DCFF.  These private code points will then be turned back into
the same bytes when the <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> error handler is used
when writing data.  This is useful for processing files in an
unknown encoding.</li>
<li><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> is only supported when writing to a file.
Characters not supported by the encoding are replaced with the
appropriate XML character reference <code class="docutils literal notranslate"><span class="pre">&amp;#nnn;</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> replaces malformed data by Python’s backslashed
escape sequences.</li>
<li><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> (also only supported when writing)
replaces unsupported characters with <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> escape sequences.</li>
</ul>
<p id="index-6"><em>newline</em> controls how <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> mode works (it only
applies to text mode).  It can be <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>, and
<code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>.  It works as follows:</p>
<ul class="simple">
<li>When reading input from the stream, if <em>newline</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, universal
newlines mode is enabled.  Lines in the input can end in <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'\r'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, and these are translated into <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> before
being returned to the caller.  If it is <code class="docutils literal notranslate"><span class="pre">''</span></code>, universal newlines mode is
enabled, but line endings are returned to the caller untranslated.  If it
has any of the other legal values, input lines are only terminated by the
given string, and the line ending is returned to the caller untranslated.</li>
<li>When writing output to the stream, if <em>newline</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, any <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>
characters written are translated to the system default line separator,
<a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.linesep</span></code></a>.  If <em>newline</em> is <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, no translation
takes place.  If <em>newline</em> is any of the other legal values, any <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>
characters written are translated to the given string.</li>
</ul>
<p>If <em>closefd</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and a file descriptor rather than a filename was
given, the underlying file descriptor will be kept open when the file is
closed.  If a filename is given <em>closefd</em> must be <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default)
otherwise an error will be raised.</p>
<p>A custom opener can be used by passing a callable as <em>opener</em>. The underlying
file descriptor for the file object is then obtained by calling <em>opener</em> with
(<em>file</em>, <em>flags</em>). <em>opener</em> must return an open file descriptor (passing
<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.open</span></code></a> as <em>opener</em> results in functionality similar to passing
<code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<p>新创建的文件是 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">不可继承的</span></a>。</p>
<p>下面的示例使用 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 函数返回值传给 <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">dir_fd</span></a> 的形参，从给定的目录中用相对路径打开文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p>The type of <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> returned by the <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> function
depends on the mode.  When <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> is used to open a file in a text
mode (<code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wt'</span></code>, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code>, etc.), it returns a subclass of
<a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> (specifically <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>).  When used
to open a file in a binary mode with buffering, the returned class is a
subclass of <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a>.  The exact class varies: in read
binary mode, it returns an <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a>; in write binary and
append binary modes, it returns an <a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedWriter</span></code></a>, and in
read/write mode, it returns an <a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedRandom</span></code></a>.  When buffering is
disabled, the raw stream, a subclass of <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a>,
<a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>, is returned.</p>
<p id="index-7">另请参阅文件操作模块，例如 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a>、<a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> （声明了 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>）、<a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>、<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a>、<a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a> 和 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>。</p>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.3 版更改: </span><ul class="simple">
<li>增加了 <em>opener</em> 形参。</li>
<li>增加了 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 模式。</li>
<li>过去触发的 <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>，现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</li>
<li>如果文件已存在但使用了排它性创建模式（ <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ），现在会触发 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.4 版更改: </span><ul class="simple">
<li>文件现在禁止继承。</li>
</ul>
</div></blockquote>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">从版本 3.4 开始标记为过时，将在版本 4.0 中移除。: </span><code class="docutils literal notranslate"><span class="pre">'U'</span></code> 模式。</p>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.5 版更改: </span><ul class="simple">
<li>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 异常（原因详见 <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>）。</li>
<li>增加了 <code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 错误处理接口。</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.6 版更改: </span><ul class="simple">
<li>增加对实现了 <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 对象的支持。</li>
<li>在 Windows 上，打开一个控制台缓冲区将返回 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的子类，而不是 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="ord">
<code class="descname">ord</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#ord" title="永久链接至目标">¶</a></dt>
<dd><p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code class="docutils literal notranslate"><span class="pre">ord('a')</span></code> 返回整数 <code class="docutils literal notranslate"><span class="pre">97</span></code>， <code class="docutils literal notranslate"><span class="pre">ord('€')</span></code> （欧元符合）返回 <code class="docutils literal notranslate"><span class="pre">8364</span></code> 。这是 <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 的逆函数。</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的 <em>y</em> 次幂；如果 <em>z</em> 存在，则对 <em>z</em> 取余（比直接 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code> 计算更高效）。两个参数形式的 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> 等价于幂运算符： <code class="docutils literal notranslate"><span class="pre">x**y</span></code>。</p>
<p>The arguments must have numeric types.  With mixed operand types, the
coercion rules for binary arithmetic operators apply.  For <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>
operands, the result has the same type as the operands (after coercion)
unless the second argument is negative; in that case, all arguments are
converted to float and a float result is delivered.  For example, <code class="docutils literal notranslate"><span class="pre">10**2</span></code>
returns <code class="docutils literal notranslate"><span class="pre">100</span></code>, but <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> returns <code class="docutils literal notranslate"><span class="pre">0.01</span></code>.  If the second argument is
negative, the third argument must be omitted.  If <em>z</em> is present, <em>x</em> and <em>y</em>
must be of integer types, and <em>y</em> must be non-negative.</p>
</dd></dl>

<dl class="function">
<dt id="print">
<code class="descname">print</code><span class="sig-paren">(</span><em>*objects</em>, <em>sep=' '</em>, <em>end='\n'</em>, <em>file=sys.stdout</em>, <em>flush=False</em><span class="sig-paren">)</span><a class="headerlink" href="#print" title="永久链接至目标">¶</a></dt>
<dd><p>Print <em>objects</em> to the text stream <em>file</em>, separated by <em>sep</em> and followed
by <em>end</em>.  <em>sep</em>, <em>end</em>, <em>file</em> and <em>flush</em>, if present, must be given as keyword
arguments.</p>
<p>All non-keyword arguments are converted to strings like <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> does and
written to the stream, separated by <em>sep</em> and followed by <em>end</em>.  Both <em>sep</em>
and <em>end</em> must be strings; they can also be <code class="docutils literal notranslate"><span class="pre">None</span></code>, which means to use the
default values.  If no <em>objects</em> are given, <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> will just write
<em>end</em>.</p>
<p>The <em>file</em> argument must be an object with a <code class="docutils literal notranslate"><span class="pre">write(string)</span></code> method; if it
is not present or <code class="docutils literal notranslate"><span class="pre">None</span></code>, <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> will be used.  Since printed
arguments are converted to text strings, <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> cannot be used with
binary mode file objects.  For these, use <code class="docutils literal notranslate"><span class="pre">file.write(...)</span></code> instead.</p>
<p>Whether output is buffered is usually determined by <em>file</em>, but if the
<em>flush</em> keyword argument is true, the stream is forcibly flushed.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>增加了 <em>flush</em> keyword 实参。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="property">
<em class="property">class </em><code class="descname">property</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#property" title="永久链接至目标">¶</a></dt>
<dd><p>返回 property 属性。</p>
<p><em>fget</em> is a function for getting an attribute value.  <em>fset</em> is a function
for setting an attribute value. <em>fdel</em> is a function for deleting an attribute
value.  And <em>doc</em> creates a docstring for the attribute.</p>
<p>A typical use is to define a managed attribute <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If <em>c</em> is an instance of <em>C</em>, <code class="docutils literal notranslate"><span class="pre">c.x</span></code> will invoke the getter,
<code class="docutils literal notranslate"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code> will invoke the setter and <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">c.x</span></code> the deleter.</p>
<p>If given, <em>doc</em> will be the docstring of the property attribute. Otherwise, the
property will copy <em>fget</em>’s docstring (if it exists).  This makes it possible to
create read-only properties easily using <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> as a <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> decorator turns the <code class="xref py py-meth docutils literal notranslate"><span class="pre">voltage()</span></code> method into a “getter”
for a read-only attribute with the same name, and it sets the docstring for
<em>voltage</em> to “Get the current voltage.”</p>
<p>A property object has <code class="xref py py-attr docutils literal notranslate"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">setter</span></code>,
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">deleter</span></code> methods usable as decorators that create a
copy of the property with the corresponding accessor function set to the
decorated function.  This is best explained with an example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>This code is exactly equivalent to the first example.  Be sure to give the
additional functions the same name as the original property (<code class="docutils literal notranslate"><span class="pre">x</span></code> in this
case.)</p>
<p>The returned property object also has the attributes <code class="docutils literal notranslate"><span class="pre">fget</span></code>, <code class="docutils literal notranslate"><span class="pre">fset</span></code>, and
<code class="docutils literal notranslate"><span class="pre">fdel</span></code> corresponding to the constructor arguments.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>The docstrings of property objects are now writeable.</p>
</div>
</dd></dl>

<span class="target" id="func-range"></span><dl class="function">
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Rather than being a function, <a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> is actually an immutable
sequence type, as documented in <a class="reference internal" href="stdtypes.html#typesseq-range"><span class="std std-ref">Ranges</span></a> and <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="repr">
<code class="descname">repr</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#repr" title="永久链接至目标">¶</a></dt>
<dd><p>Return a string containing a printable representation of an object.  For many
types, this function makes an attempt to return a string that would yield an
object with the same value when passed to <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>, otherwise the
representation is a string enclosed in angle brackets that contains the name
of the type of the object together with additional information often
including the name and address of the object.  A class can control what this
function returns for its instances by defining a <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> method.</p>
</dd></dl>

<dl class="function">
<dt id="reversed">
<code class="descname">reversed</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#reversed" title="永久链接至目标">¶</a></dt>
<dd><p>Return a reverse <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.  <em>seq</em> must be an object which has
a <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> method or supports the sequence protocol (the
<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> method and the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method with integer
arguments starting at <code class="docutils literal notranslate"><span class="pre">0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="round">
<code class="descname">round</code><span class="sig-paren">(</span><em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#round" title="永久链接至目标">¶</a></dt>
<dd><p>Return <em>number</em> rounded to <em>ndigits</em> precision after the decimal
point.  If <em>ndigits</em> is omitted or is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it returns the
nearest integer to its input.</p>
<p>For the built-in types supporting <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>, values are rounded to the
closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are
equally close, rounding is done toward the even choice (so, for example,
both <code class="docutils literal notranslate"><span class="pre">round(0.5)</span></code> and <code class="docutils literal notranslate"><span class="pre">round(-0.5)</span></code> are <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">round(1.5)</span></code> is
<code class="docutils literal notranslate"><span class="pre">2</span></code>).  Any integer value is valid for <em>ndigits</em> (positive, zero, or
negative).  The return value is an integer if <em>ndigits</em> is omitted or
<code class="docutils literal notranslate"><span class="pre">None</span></code>.
Otherwise the return value has the same type as <em>number</em>.</p>
<p>For a general Python object <code class="docutils literal notranslate"><span class="pre">number</span></code>, <code class="docutils literal notranslate"><span class="pre">round</span></code> delegates to
<code class="docutils literal notranslate"><span class="pre">number.__round__</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">The behavior of <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> for floats can be surprising: for example,
<code class="docutils literal notranslate"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> gives <code class="docutils literal notranslate"><span class="pre">2.67</span></code> instead of the expected <code class="docutils literal notranslate"><span class="pre">2.68</span></code>.
This is not a bug: it’s a result of the fact that most decimal fractions
can’t be represented exactly as a float.  See <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">Floating Point Arithmetic:  Issues and Limitations</span></a> for
more information.</p>
</div>
</dd></dl>

<span class="target" id="func-set"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Return a new <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> object, optionally with elements taken from
<em>iterable</em>.  <code class="docutils literal notranslate"><span class="pre">set</span></code> is a built-in class.  See <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and
<a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">Set Types — set, frozenset</span></a> for documentation about this class.</p>
<p>For other containers see the built-in <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>,
<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, and <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> classes, as well as the <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>
module.</p>
</dd></dl>

<dl class="function">
<dt id="setattr">
<code class="descname">setattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#setattr" title="永久链接至目标">¶</a></dt>
<dd><p>This is the counterpart of <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.  The arguments are an object, a
string and an arbitrary value.  The string may name an existing attribute or a
new attribute.  The function assigns the value to the attribute, provided the
object allows it.  For example, <code class="docutils literal notranslate"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="slice">
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#slice" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p id="index-9">Return a <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a> object representing the set of indices specified by
<code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code>.  The <em>start</em> and <em>step</em> arguments default to
<code class="docutils literal notranslate"><span class="pre">None</span></code>.  Slice objects have read-only data attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> which merely return the argument
values (or their default).  They have no other explicit functionality;
however they are used by Numerical Python and other third party extensions.
Slice objects are also generated when extended indexing syntax is used.  For
example: <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> or <code class="docutils literal notranslate"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>.  See
<a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> for an alternate version that returns an iterator.</p>
</dd></dl>

<dl class="function">
<dt id="sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sorted" title="永久链接至目标">¶</a></dt>
<dd><p>Return a new sorted list from the items in <em>iterable</em>.</p>
<p>Has two optional arguments which must be specified as keyword arguments.</p>
<p><em>key</em> specifies a function of one argument that is used to extract a comparison
key from each list element: <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>.  The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>
(compare the elements directly).</p>
<p><em>reverse</em> is a boolean value.  If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the list elements are
sorted as if each comparison were reversed.</p>
<p>Use <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> to convert an old-style <em>cmp</em> function to a
<em>key</em> function.</p>
<p>The built-in <a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> function is guaranteed to be stable. A sort is
stable if it guarantees not to change the relative order of elements that
compare equal — this is helpful for sorting in multiple passes (for
example, sort by department, then by salary grade).</p>
<p>For sorting examples and a brief sorting tutorial, see <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="staticmethod">
<code class="descclassname">&#64;</code><code class="descname">staticmethod</code><a class="headerlink" href="#staticmethod" title="永久链接至目标">¶</a></dt>
<dd><p>Transform a method into a static method.</p>
<p>A static method does not receive an implicit first argument. To declare a static
method, use this idiom:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> form is a function <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> – see the
description of function definitions in <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">Function definitions</span></a> for details.</p>
<p>It can be called either on the class (such as <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>) or on an instance (such
as <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>).  The instance is ignored except for its class.</p>
<p>Static methods in Python are similar to those found in Java or C++. Also see
<a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> for a variant that is useful for creating alternate class
constructors.</p>
<p>Like all decorators, it is also possible to call <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> as
a regular function and do something with its result.  This is needed
in some cases where you need a reference to a function from a class
body and you want to avoid the automatic transformation to instance
method.  For these cases, use this idiom:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">builtin_open</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="nb">open</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on static methods, consult the documentation on the
standard type hierarchy in <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">The standard type hierarchy</span></a>.</p>
</dd></dl>

<span class="target" id="func-str"><span id="index-10"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p>Return a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> version of <em>object</em>.  See <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> for details.</p>
<p><code class="docutils literal notranslate"><span class="pre">str</span></code> is the built-in string <a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">class</span></a>.  For general information
about strings, see <a class="reference internal" href="stdtypes.html#textseq"><span class="std std-ref">Text Sequence Type — str</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="永久链接至目标">¶</a></dt>
<dd><p>Sums <em>start</em> and the items of an <em>iterable</em> from left to right and returns the
total.  <em>start</em> defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>. The <em>iterable</em>’s items are normally numbers,
and the start value is not allowed to be a string.</p>
<p>For some use cases, there are good alternatives to <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>.
The preferred, fast way to concatenate a sequence of strings is by calling
<code class="docutils literal notranslate"><span class="pre">''.join(sequence)</span></code>.  To add floating point values with extended precision,
see <a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fsum()</span></code></a>.  To concatenate a series of iterables, consider using
<a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.chain()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="super">
<code class="descname">super</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#super" title="永久链接至目标">¶</a></dt>
<dd><p>Return a proxy object that delegates method calls to a parent or sibling
class of <em>type</em>.  This is useful for accessing inherited methods that have
been overridden in a class. The search order is same as that used by
<a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> except that the <em>type</em> itself is skipped.</p>
<p>The <a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> attribute of the <em>type</em> lists the method
resolution search order used by both <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> and <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>.  The
attribute is dynamic and can change whenever the inheritance hierarchy is
updated.</p>
<p>If the second argument is omitted, the super object returned is unbound.  If
the second argument is an object, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> must be true.  If
the second argument is a type, <code class="docutils literal notranslate"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> must be true (this
is useful for classmethods).</p>
<p>There are two typical use cases for <em>super</em>.  In a class hierarchy with
single inheritance, <em>super</em> can be used to refer to parent classes without
naming them explicitly, thus making the code more maintainable.  This use
closely parallels the use of <em>super</em> in other programming languages.</p>
<p>The second use case is to support cooperative multiple inheritance in a
dynamic execution environment.  This use case is unique to Python and is
not found in statically compiled languages or languages that only support
single inheritance.  This makes it possible to implement “diamond diagrams”
where multiple base classes implement the same method.  Good design dictates
that this method have the same calling signature in every case (because the
order of calls is determined at runtime, because that order adapts
to changes in the class hierarchy, and because that order can include
sibling classes that are unknown prior to runtime).</p>
<p>For both use cases, a typical superclass call looks like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> is implemented as part of the binding process for
explicit dotted attribute lookups such as <code class="docutils literal notranslate"><span class="pre">super().__getitem__(name)</span></code>.
It does so by implementing its own <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method for searching
classes in a predictable order that supports cooperative multiple inheritance.
Accordingly, <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> is undefined for implicit lookups using statements or
operators such as <code class="docutils literal notranslate"><span class="pre">super()[name]</span></code>.</p>
<p>Also note that, aside from the zero argument form, <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> is not
limited to use inside methods.  The two argument form specifies the
arguments exactly and makes the appropriate references.  The zero
argument form only works inside a class definition, as the compiler fills
in the necessary details to correctly retrieve the class being defined,
as well as accessing the current instance for ordinary methods.</p>
<p>For practical suggestions on how to design cooperative classes using
<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>, see <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">guide to using super()</a>.</p>
</dd></dl>

<span class="target" id="func-tuple"></span><dl class="function">
<dt>
<code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Rather than being a function, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> is actually an immutable
sequence type, as documented in <a class="reference internal" href="stdtypes.html#typesseq-tuple"><span class="std std-ref">Tuples</span></a> and <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>.</p>
</dd></dl>

<dl class="class">
<dt id="type">
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>name</em>, <em>bases</em>, <em>dict</em><span class="sig-paren">)</span></dt>
<dd><p id="index-11">With one argument, return the type of an <em>object</em>.  The return value is a
type object and generally the same object as returned by
<a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__class__</span></code></a>.</p>
<p>The <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> built-in function is recommended for testing the type
of an object, because it takes subclasses into account.</p>
<p>With three arguments, return a new type object.  This is essentially a
dynamic form of the <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> statement. The <em>name</em> string is the
class name and becomes the <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> attribute; the <em>bases</em>
tuple itemizes the base classes and becomes the <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a>
attribute; and the <em>dict</em> dictionary is the namespace containing definitions
for class body and is copied to a standard dictionary to become the
<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute.  For example, the following two
statements create identical <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> objects:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="stdtypes.html#bltin-type-objects"><span class="std std-ref">Type Objects</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>Subclasses of <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> which don’t override <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> may no
longer use the one-argument form to get the type of an object.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="vars">
<code class="descname">vars</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#vars" title="永久链接至目标">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute for a module, class, instance,
or any other object with a <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute.</p>
<p>Objects such as modules and instances have an updateable <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
attribute; however, other objects may have write restrictions on their
<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attributes (for example, classes use a
<a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> to prevent direct dictionary updates).</p>
<p>Without an argument, <a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a> acts like <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>.  Note, the
locals dictionary is only useful for reads since updates to the locals
dictionary are ignored.</p>
</dd></dl>

<dl class="function">
<dt id="zip">
<code class="descname">zip</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#zip" title="永久链接至目标">¶</a></dt>
<dd><p>Make an iterator that aggregates elements from each of the iterables.</p>
<p>Returns an iterator of tuples, where the <em>i</em>-th tuple contains
the <em>i</em>-th element from each of the argument sequences or iterables.  The
iterator stops when the shortest input iterable is exhausted. With a single
iterable argument, it returns an iterator of 1-tuples.  With no arguments,
it returns an empty iterator.  Equivalent to:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># zip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>The left-to-right evaluation order of the iterables is guaranteed. This
makes possible an idiom for clustering a data series into n-length groups
using <code class="docutils literal notranslate"><span class="pre">zip(*[iter(s)]*n)</span></code>.  This repeats the <em>same</em> iterator <code class="docutils literal notranslate"><span class="pre">n</span></code> times
so that each output tuple has the result of <code class="docutils literal notranslate"><span class="pre">n</span></code> calls to the iterator.
This has the effect of dividing the input into n-length chunks.</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> should only be used with unequal length inputs when you don’t
care about trailing, unmatched values from the longer iterables.  If those
values are important, use <a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a> instead.</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> in conjunction with the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator can be used to unzip a
list:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="__import__">
<code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#__import__" title="永久链接至目标">¶</a></dt>
<dd><div class="admonition note" id="index-12">
<p class="first admonition-title">注解</p>
<p class="last">This is an advanced function that is not needed in everyday Python
programming, unlike <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
</div>
<p>This function is invoked by the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement.  It can be
replaced (by importing the <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> module and assigning to
<code class="docutils literal notranslate"><span class="pre">builtins.__import__</span></code>) in order to change semantics of the
<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement, but doing so is <strong>strongly</strong> discouraged as it
is usually simpler to use import hooks (see <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>) to attain the same
goals and does not cause issues with code which assumes the default import
implementation is in use.  Direct use of <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> is also
discouraged in favor of <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<p>The function imports the module <em>name</em>, potentially using the given <em>globals</em>
and <em>locals</em> to determine how to interpret the name in a package context.
The <em>fromlist</em> gives the names of objects or submodules that should be
imported from the module given by <em>name</em>.  The standard implementation does
not use its <em>locals</em> argument at all, and uses its <em>globals</em> only to
determine the package context of the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement.</p>
<p><em>level</em> specifies whether to use absolute or relative imports. <code class="docutils literal notranslate"><span class="pre">0</span></code> (the
default) means only perform absolute imports.  Positive values for
<em>level</em> indicate the number of parent directories to search relative to the
directory of the module calling <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> (see <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> for the
details).</p>
<p>When the <em>name</em> variable is of the form <code class="docutils literal notranslate"><span class="pre">package.module</span></code>, normally, the
top-level package (the name up till the first dot) is returned, <em>not</em> the
module named by <em>name</em>.  However, when a non-empty <em>fromlist</em> argument is
given, the module named by <em>name</em> is returned.</p>
<p>For example, the statement <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam</span></code> results in bytecode resembling the
following code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The statement <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam.ham</span></code> results in this call:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> returns the toplevel module here because this is
the object that is bound to a name by the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement.</p>
<p>On the other hand, the statement <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span>
<span class="pre">saus</span></code> results in</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">spam.ham</span></code> module is returned from <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.  From this
object, the names to import are retrieved and assigned to their respective
names.</p>
<p>If you simply want to import a module (potentially within a package) by name,
use <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>Negative values for <em>level</em> are no longer supported (which also changes
the default value to 0).</p>
</div>
</dd></dl>

<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换Windows 或 Mac 风格的换行符。</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="intro.html"
                        title="上一章">1. Introduction</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="constants.html"
                        title="下一章">3. Built-in Constants</a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/functions.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="全文档索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             >下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. Introduction"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.6.5 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="立即搜索" type="text" name="q" />
          <input type="submit" value="查找" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权信息</a> 2001-2018, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    上次更新于 6月 11, 2018。
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>1.7.5 创建。
    </div>

  </body>
</html>